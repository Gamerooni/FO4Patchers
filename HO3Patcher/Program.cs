using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System.Linq;
using System.Runtime;
using Mutagen.Bethesda.Plugins.Records;
using System.Data;

namespace HO3Patcher
{
    public class Program
    {
        public static Lazy<HO3Settings> _settings = null!;
        public static HO3Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                "Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "HO3Patcher.esp")
                .Run(args);
        }

        /// <inheritdoc cref="GetAllRulesForArmor(IArmorGetter, ILinkCache)" path="//param"/>
        /// <summary>
        /// Checks if <paramref name="matcher"/>'s rules apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="matcher">The rule as defined in the settings</param>
        /// <returns><c>true</c> if we have a match, <c>false</c> otherwise</returns>
        public static bool IsArmorMatchedBySetting(IArmorGetter armor, ArmorMatcher matcher, ILinkCache linkCache)
        {
            var matcherOperations = new ArmorMatcherOperations(matcher, linkCache);
            return matcherOperations.MatchArmor(armor);
        }

        /// <summary>
        /// Adds a float property <paramref name="propName"/> with value <paramref name="value"/> to script <paramref name="scriptName"/> of armor <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">Armor setter to modify. Does not need to have existing VMAD</param>
        /// <param name="scriptName">Name of script. Does not need to exist.</param>
        /// <param name="propName">Name of property. Does not need to exist.</param>
        /// <param name="value">New value of property</param>
        /// <returns><c>true</c> if we changed the script at all, false otherwise</returns>
        public static bool AddScriptFloatProp(IArmor armor, string scriptName, string propName, float value)
        {
            bool modified = true;

            if (armor.VirtualMachineAdapter == null)
            {
                var newVMAD = new VirtualMachineAdapter
                {
                    Version = VirtualMachineAdapter.VersionDefault,
                    ObjectFormat = VirtualMachineAdapter.ObjectFormatDefault,
                    Scripts = new ExtendedList<ScriptEntry>()
                };
                armor.VirtualMachineAdapter = newVMAD;
            }

            var newHhsHeightProp = new ScriptFloatProperty
            {
                Name = propName,
                Data = value
            };

            // Assume no duplicate scripts
            var HHSScript = armor.VirtualMachineAdapter.Scripts.Find(script => script.Name.Equals(scriptName));

            if (HHSScript == null)
            {
                var newScript = new ScriptEntry
                {
                    Name = scriptName,
                    Flags = ScriptEntry.Flag.Local,
                    Properties = new ExtendedList<ScriptProperty>
                    {
                        newHhsHeightProp
                    }
                };
                armor.VirtualMachineAdapter.Scripts.Add(newScript);
            }
            else
            {
                var heightProp = HHSScript.Properties.Find(prop => prop.Name.Equals(propName));

                if (heightProp == null)
                {
                    HHSScript.Properties.Add(newHhsHeightProp);
                }
                else
                {
                    var heightPropFloat = heightProp as ScriptFloatProperty;

                    if (heightPropFloat == null)
                    {
                        heightProp = newHhsHeightProp;
                    }
                    else
                    {
                        if (heightPropFloat.Data.Equals(value))
                        {
                            modified = false;
                        }
                        else
                        {
                            heightPropFloat.Data = value;
                        }
                    }
                }
            }
            return modified;
        }

        /// <summary>
        /// Applies <paramref name="rule"/> to <paramref name="armor"/> by replacing the HHSHeight, as defined in the <paramref name="rule"/>.
        /// </summary>
        /// <param name="armor">Mutable Armor record to apply <paramref name="rule"/> to</param>
        /// <param name="rule"></param>
        /// <returns><c>true</c> if <paramref name="armor"/> has been modified, <c>false</c> otherwise.</returns>
        public static bool ApplyRuleToArmor(IArmor armor, HHSRules rule)
        {
            bool modified = AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "HHSHeight", rule.HHSHeight);
            if (AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "GroundClipAllowance", rule.GroundClipAllowance))
            {
                return true;
            } else
            {
                return modified;
            }
        }

        /// <inheritdoc cref="ApplyRuleToArmor(IArmor, KeywordRules)" path="//returns|//param"/>
        /// <summary>
        /// Applies all rules in <paramref name="rules"/> to <paramref name="armor"/> in the given order.
        /// </summary>
        /// <param name="rules">The rules in question</param>
        public static bool ApplyRulesToArmor(IArmor armor, IEnumerable<KeyValuePair<int, HHSRules>> rules)
        {
            var result = false;
            foreach (var rule in rules)
            {
                if (ApplyRuleToArmor(armor, rule.Value)) result = true;
            }
            return result;
        }

        /// <summary>
        /// Gets all rules which apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">The Armor record to check</param>
        /// <param name="linkCache">Link cache to retrieve Keywords with</param>
        /// <returns>All rules which apply to <paramref name="armor"/>, ordered in ascending order by <see cref="KeywordRules.Priority"/></returns>
        public static SortedList<int, HHSRules> GetAllRulesForArmor(IArmorGetter armor, ILinkCache linkCache)
        {
            var rules = new SortedList<int, HHSRules>();
            foreach (var rule in Settings.Rules)
            {
                if (IsArmorMatchedBySetting(armor, rule.MatchingRules, linkCache))
                {
                    rules[rule.Priority] = rule;
                }
            }
            return rules;
        }

        public static void ProcessArmor(IArmor armor, ILinkCache linkCache)
        {
            ApplyRulesToArmor(armor, GetAllRulesForArmor(armor, linkCache));
        }

        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            var shortenedLoadOrder = Settings.ModsToPatch.Any() ? state.LoadOrder.PriorityOrder
                .Where(mod => Settings.ModsToPatch.Contains(mod.ModKey)) : state.LoadOrder.PriorityOrder;

            var linkCache = shortenedLoadOrder.ToImmutableLinkCache();

            foreach (var armor in shortenedLoadOrder.WinningOverrides<IArmorGetter>())
            {
                var rules = GetAllRulesForArmor(armor, linkCache);
                var newArmor = armor.DeepCopy();
                if (ApplyRulesToArmor(newArmor, rules))
                {
                    state.PatchMod.Armors.Add(newArmor);
                }
            }
        }
    }
}
