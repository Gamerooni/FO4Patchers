using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Plugins.Cache;
using Noggog;
using Mutagen.Bethesda.Plugins.Records;
using System.Data;

namespace HO3Patcher
{
    public class Program
    {
        public static Lazy<HO3Settings> _settings = null!;
        public static HO3Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                "Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Fallout4, "HO3Patcher.esp")
                .Run(args);
        }

        /// <inheritdoc cref="GetAllRulesForArmor(IArmorGetter, ILinkCache)" path="//param"/>
        /// <summary>
        /// Checks if <paramref name="matcher"/>'s rules apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="matcher">The rule as defined in the settings</param>
        /// <returns><c>true</c> if we have a match, <c>false</c> otherwise</returns>
        public static bool IsArmorMatchedBySetting(IArmorGetter armor, ArmorMatcher matcher, ILinkCache linkCache)
        {
            var matcherOperations = new ArmorMatcherOperations(matcher, linkCache);
            return matcherOperations.MatchArmor(armor);
        }

        /// <summary>
        /// Adds a float property <paramref name="propName"/> with value <paramref name="value"/> to script <paramref name="scriptName"/> of armor <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">Armor setter to modify. Does not need to have existing VMAD</param>
        /// <param name="scriptName">Name of script. Does not need to exist.</param>
        /// <param name="propName">Name of property. Does not need to exist.</param>
        /// <param name="value">New value of property</param>
        /// <returns><c>true</c> if we changed the script at all, false otherwise</returns>
        public static bool AddScriptFloatProp(IArmor armor, string scriptName, string propName, float value)
        {
            bool modified = true;

            if (armor.VirtualMachineAdapter == null)
            {
                var newVMAD = new VirtualMachineAdapter
                {
                    Version = VirtualMachineAdapter.VersionDefault,
                    ObjectFormat = VirtualMachineAdapter.ObjectFormatDefault,
                    Scripts = new ExtendedList<ScriptEntry>()
                };
                armor.VirtualMachineAdapter = newVMAD;
            }

            var newHhsHeightProp = new ScriptFloatProperty
            {
                Name = propName,
                Data = value
            };

            // Assume no duplicate scripts
            var HHSScript = armor.VirtualMachineAdapter.Scripts.Find(script => script.Name.Equals(scriptName));

            if (HHSScript == null)
            {
                var newScript = new ScriptEntry
                {
                    Name = scriptName,
                    Flags = ScriptEntry.Flag.Local,
                    Properties = new ExtendedList<ScriptProperty>
                    {
                        newHhsHeightProp
                    }
                };
                armor.VirtualMachineAdapter.Scripts.Add(newScript);
            }
            else
            {
                var heightProp = HHSScript.Properties.Find(prop => prop.Name.Equals(propName));

                if (heightProp == null)
                {
                    HHSScript.Properties.Add(newHhsHeightProp);
                }
                else
                {
                    var heightPropFloat = heightProp as ScriptFloatProperty;

                    if (heightPropFloat == null)
                    {
                        heightProp = newHhsHeightProp;
                    }
                    else
                    {
                        if (heightPropFloat.Data.Equals(value))
                        {
                            modified = false;
                        }
                        else
                        {
                            heightPropFloat.Data = value;
                        }
                    }
                }
            }
            return modified;
        }

        /// <summary>
        /// Applies <paramref name="rule"/> to <paramref name="armor"/> by replacing the HHSHeight, as defined in the <paramref name="rule"/>.
        /// </summary>
        /// <param name="armor">Mutable Armor record to apply <paramref name="rule"/> to</param>
        /// <param name="rule"></param>
        /// <returns><c>true</c> if <paramref name="armor"/> has been modified, <c>false</c> otherwise.</returns>
        public static bool ApplyRuleToArmor(IArmor armor, HHSRules rule)
        {
            bool modified = AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "HHSHeight", rule.HHSHeight);
            if (AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "GroundClipAllowance", rule.GroundClipAllowance))
            {
                return true;
            } else
            {
                return modified;
            }
        }

        /// <inheritdoc cref="ApplyRuleToArmor(IArmor, KeywordRules)" path="//returns|//param"/>
        /// <summary>
        /// Applies all rules in <paramref name="rules"/> to <paramref name="armor"/> in the given order.
        /// </summary>
        /// <param name="rules">The rules in question</param>
        public static bool ApplyRulesToArmor(IArmor armor, IEnumerable<KeyValuePair<int, HHSRules>> rules)
        {
            var result = false;
            foreach (var rule in rules)
            {
                if (ApplyRuleToArmor(armor, rule.Value)) result = true;
            }
            return result;
        }

        /// <summary>
        /// Checks whether file at given filepath is an HHS-compatible setting
        /// </summary>
        /// <param name="filePath">Path to the file (relative to VFS)</param>
        /// <returns><c>true</c> if the file exists, is a <c>.txt</c>, and its first line is of the form <c>Height=[value]</c>, where [value] is some float</returns>
        public static bool IsHHSFileValid(string filePath)
        {
            if (!Path.HasExtension(filePath) || Path.GetExtension(filePath) != ".txt")
            {
                return false;
            }
            using (StreamReader reader = File.OpenText(filePath))
            {
                string? line = reader.ReadLine();
                if (line.IsNullOrWhitespace()) return false;
                var splitLine = line.Split('=');
                if (splitLine.Length != 2) return false;
                if (splitLine[0].ToLower() == "height" && splitLine[1].IsNumeric())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Parses file at <paramref name="filePath"/> and converts it into an <see cref="HHSRules"/> object
        /// </summary>
        /// <param name="filePath">Path to a valid HHS settings file (relative to VFS)</param>
        /// <returns>A new <see cref="HHSRules"/> object with <c>HHSHeight</c> set as per the file, and matching <c>.nif</c> files only if they match.</returns>
        public static HHSRules HHSFileToRule(string filePath)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            float height;
            using (StreamReader reader = File.OpenText(filePath))
            {
                var line = reader.ReadLine();
                height = float.Parse(line!.Split('=')[1]);
            }
            return new HHSRules()
            {
                HHSHeight = height,
                MatchingRules = new ArmorMatcher()
                {
                    AND = true,
                    NifRegex = $"^{fileName}$"
                }
            };
        }

        public static IEnumerable<HHSRules> HHSFilesToRules(IEnumerable<string> filePaths)
        {
            return filePaths.Select(filePath => HHSFileToRule(filePath));
        }

        public static IEnumerable<string> GetAllValidHHSFiles(string path)
        {
            var files = Directory.GetFiles(path, "*.txt", SearchOption.AllDirectories);
            return files.Where(file => IsHHSFileValid(file)).ToList();
        }

        public static void MoveFiles(IEnumerable<string> relativeFilePaths, string backupPath, string gamePath)
        {
            foreach (var filePath in relativeFilePaths)
            {
                File.Move(Path.Combine(gamePath, filePath), Path.Combine(backupPath, filePath), overwrite:true);
            }
        }

        /// <summary>
        /// Gets all rules which apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">The Armor record to check</param>
        /// <param name="linkCache">Link cache to retrieve Keywords with</param>
        /// <returns>All rules which apply to <paramref name="armor"/>, ordered in ascending order by <see cref="KeywordRules.Priority"/></returns>
        public static SortedList<int, HHSRules> GetAllRulesForArmor(IArmorGetter armor, ILinkCache linkCache, IEnumerable<HHSRules> allRules)
        {
            var rules = new SortedList<int, HHSRules>();
            foreach (var rule in allRules)
            {
                if (IsArmorMatchedBySetting(armor, rule.MatchingRules, linkCache))
                {
                    rules[rule.Priority] = rule;
                }
            }
            return rules;
        }

        public static IEnumerable<HHSRules> FilterRulesByNif(IArmorGetter armor, Dictionary<string, HHSRules> exactNifRules, ILinkCache linkCache)
        {
            List<HHSRules> filteredRules = new List<HHSRules>();
            foreach (IArmorAddonModelGetter armorAddon in armor.Armatures)
            {
                var addon = armorAddon.AddonModel.TryResolve(linkCache);
                if (addon?.WorldModel == null || !addon.WorldModel.Any())
                {
                    continue;
                }
                foreach(var model in addon.WorldModel)
                {
                    if (model == null) continue;
                    var file = Path.GetFileNameWithoutExtension(model.File);
                    if (file.IsNullOrWhitespace()) continue;
                    if (exactNifRules.TryGetValue(file, out var rule))
                    {
                        filteredRules.Add(rule);
                        break;
                    }
                }
            }
            return filteredRules;
        }

        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            var shortenedLoadOrder = Settings.ModsToPatch.Any() ? state.LoadOrder.PriorityOrder
                .Where(mod => Settings.ModsToPatch.Contains(mod.ModKey)) : state.LoadOrder.PriorityOrder;

            var linkCache = shortenedLoadOrder.ToImmutableLinkCache();

            string dataPath = state.DataFolderPath.RelativePath;

            var f4seFiles = GetAllValidHHSFiles(Path.Join(dataPath, "F4SE", "Plugins", "HHS"));
            var meshFiles = GetAllValidHHSFiles(Path.Join(dataPath, "Meshes"));
            var allValidFiles = f4seFiles.Concat(meshFiles);

            var allRules = Settings.Rules.Concat(HHSFilesToRules(allValidFiles));
            Console.WriteLine($"We now got {allRules.Count()} rules");
            List<string> allNifRules = allRules.Where(rule => rule.MatchingRules.AND).Select(rule => rule.MatchingRules.NifRegex).ToList();

            Dictionary<string, HHSRules> exactNifMatches = new Dictionary<string, HHSRules>();
            allRules
                .Where(rule => rule.MatchingRules.AND
                    && rule.MatchingRules.NifRegex.Length > 0
                    && rule.MatchingRules.NifRegex[0] == '^'
                    && rule.MatchingRules.NifRegex[rule.MatchingRules.NifRegex.Length - 1] == '$')
                .ForEach(rule => exactNifMatches[rule.MatchingRules.NifRegex.Substring(1, rule.MatchingRules.NifRegex.Length - 2)] = rule);
            Console.WriteLine("----------Files read----------");
            Console.WriteLine($"Filtered this many exact .nif matches: {exactNifMatches.Count}");

            var allCount = 0;
            var patchedCount = 0;

            foreach (var armor in shortenedLoadOrder.WinningOverrides<IArmorGetter>())
            {
                allCount++;
                var rules = GetAllRulesForArmor(armor, linkCache, FilterRulesByNif(armor, exactNifMatches, linkCache));
                var newArmor = armor.DeepCopy();
                if (ApplyRulesToArmor(newArmor, rules))
                {
                    Console.WriteLine($"Applied rule to {newArmor.Name}");
                    patchedCount++;
                    state.PatchMod.Armors.Add(newArmor);
                }
            }

            Console.WriteLine("===========Patch Completed===========");
            Console.WriteLine($"{patchedCount} armours out of {allCount} patched");
            /*Console.WriteLine("Moving files to \\HeelsBackup\\...");
            MoveFiles(allValidFiles.Select(file => Path.GetRelativePath(dataPath, file)), Path.Combine(dataPath, "HeelsBackup"), dataPath);
            Console.WriteLine("Moved files to \\HeelsBackup\\!");*/
        }
    }
}
