using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Fallout4;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins;
using Noggog;
using System.Linq;
using System.Runtime;
using Mutagen.Bethesda.Plugins.Records;
using System.Data;
using System.Security.Policy;

namespace HO3Patcher
{
    public class Program
    {
        public static Lazy<HO3Settings> _settings = null!;
        public static HO3Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<IFallout4Mod, IFallout4ModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                "Settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.Fallout4, "HO3Patcher.esp")
                .Run(args);
        }

        /// <inheritdoc cref="GetAllRulesForArmor(IArmorGetter, ILinkCache)" path="//param"/>
        /// <summary>
        /// Checks if <paramref name="matcher"/>'s rules apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="matcher">The rule as defined in the settings</param>
        /// <returns><c>true</c> if we have a match, <c>false</c> otherwise</returns>
        public static bool IsArmorMatchedBySetting(IArmorGetter armor, ArmorMatcher matcher, ILinkCache linkCache)
        {
            var matcherOperations = new ArmorMatcherOperations(matcher, linkCache);
            return matcherOperations.MatchArmor(armor);
        }

        /// <summary>
        /// Adds a float property <paramref name="propName"/> with value <paramref name="value"/> to script <paramref name="scriptName"/> of armor <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">Armor setter to modify. Does not need to have existing VMAD</param>
        /// <param name="scriptName">Name of script. Does not need to exist.</param>
        /// <param name="propName">Name of property. Does not need to exist.</param>
        /// <param name="value">New value of property</param>
        /// <returns><c>true</c> if we changed the script at all, false otherwise</returns>
        public static bool AddScriptFloatProp(IArmor armor, string scriptName, string propName, float value)
        {
            bool modified = true;

            if (armor.VirtualMachineAdapter == null)
            {
                var newVMAD = new VirtualMachineAdapter
                {
                    Version = VirtualMachineAdapter.VersionDefault,
                    ObjectFormat = VirtualMachineAdapter.ObjectFormatDefault,
                    Scripts = new ExtendedList<ScriptEntry>()
                };
                armor.VirtualMachineAdapter = newVMAD;
            }

            var newHhsHeightProp = new ScriptFloatProperty
            {
                Name = propName,
                Data = value
            };

            // Assume no duplicate scripts
            var HHSScript = armor.VirtualMachineAdapter.Scripts.Find(script => script.Name.Equals(scriptName));

            if (HHSScript == null)
            {
                var newScript = new ScriptEntry
                {
                    Name = scriptName,
                    Flags = ScriptEntry.Flag.Local,
                    Properties = new ExtendedList<ScriptProperty>
                    {
                        newHhsHeightProp
                    }
                };
                armor.VirtualMachineAdapter.Scripts.Add(newScript);
            }
            else
            {
                var heightProp = HHSScript.Properties.Find(prop => prop.Name.Equals(propName));

                if (heightProp == null)
                {
                    HHSScript.Properties.Add(newHhsHeightProp);
                }
                else
                {
                    var heightPropFloat = heightProp as ScriptFloatProperty;

                    if (heightPropFloat == null)
                    {
                        heightProp = newHhsHeightProp;
                    }
                    else
                    {
                        if (heightPropFloat.Data.Equals(value))
                        {
                            modified = false;
                        }
                        else
                        {
                            heightPropFloat.Data = value;
                        }
                    }
                }
            }
            return modified;
        }

        /// <summary>
        /// Applies <paramref name="rule"/> to <paramref name="armor"/> by replacing the HHSHeight, as defined in the <paramref name="rule"/>.
        /// </summary>
        /// <param name="armor">Mutable Armor record to apply <paramref name="rule"/> to</param>
        /// <param name="rule"></param>
        /// <returns><c>true</c> if <paramref name="armor"/> has been modified, <c>false</c> otherwise.</returns>
        public static bool ApplyRuleToArmor(IArmor armor, HHSRules rule)
        {
            bool modified = AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "HHSHeight", rule.HHSHeight);
            if (AddScriptFloatProp(armor, "HHSOutfit3:HHSOutfit3", "GroundClipAllowance", rule.GroundClipAllowance))
            {
                return true;
            } else
            {
                return modified;
            }
        }

        /// <inheritdoc cref="ApplyRuleToArmor(IArmor, KeywordRules)" path="//returns|//param"/>
        /// <summary>
        /// Applies all rules in <paramref name="rules"/> to <paramref name="armor"/> in the given order.
        /// </summary>
        /// <param name="rules">The rules in question</param>
        public static bool ApplyRulesToArmor(IArmor armor, IEnumerable<KeyValuePair<int, HHSRules>> rules)
        {
            var result = false;
            foreach (var rule in rules)
            {
                if (ApplyRuleToArmor(armor, rule.Value)) result = true;
            }
            return result;
        }

        /// <summary>
        /// Checks whether file at given filepath is an HHS-compatible setting
        /// </summary>
        /// <param name="filePath">Path to the file (relative to VFS)</param>
        /// <returns><c>true</c> if the file exists, is a <c>.txt</c>, and its first line is of the form <c>Height=[value]</c>, where [value] is some float</returns>
        public static bool IsHHSFileValid(string filePath)
        {
            if (!Path.HasExtension(filePath) || Path.GetExtension(filePath) != ".txt")
            {
                return false;
            }
            using (StreamReader reader = File.OpenText(filePath))
            {
                string? line = reader.ReadLine();
                if (line.IsNullOrWhitespace()) return false;
                var splitLine = line.Split('=');
                if (splitLine.Length != 2) return false;
                if (splitLine[0].ToLower() == "height" && splitLine[1].IsNumeric())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Parses file at <paramref name="filePath"/> and converts it into an <see cref="HHSRules"/> object
        /// </summary>
        /// <param name="filePath">Path to a valid HHS settings file (relative to VFS)</param>
        /// <returns>A new <see cref="HHSRules"/> object with <c>HHSHeight</c> set as per the file, and matching <c>.nif</c> files only if they match.</returns>
        public static HHSRules HHSFileToRule(string filePath)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            float height;
            using (StreamReader reader = File.OpenText(filePath))
            {
                var line = reader.ReadLine();
                height = float.Parse(line!.Split('=')[1]);
            }
            return new HHSRules()
            {
                HHSHeight = height,
                MatchingRules = new ArmorMatcher()
                {
                    NifRegex = $"^{fileName}$"
                }
            };
            //return newRule;
        }

        public static IEnumerable<HHSRules> HHSFilesToRules(IEnumerable<string> filePaths)
        {
            return filePaths.Select(filePath => HHSFileToRule(filePath));
        }

        public static IEnumerable<string> GetAllValidHHSFiles(string path)
        {
            var files = Directory.GetFiles(path, "*.txt", SearchOption.AllDirectories);
            Console.WriteLine("all the files:");
            files.ForEach(file => Console.WriteLine(file));
            Console.WriteLine(files.Length);
            return files.Where(file => IsHHSFileValid(file)).ToList();
        }

        public static void MoveFiles(IEnumerable<string> relativeFilePaths, string backupPath, string gamePath)
        {
            foreach (var filePath in relativeFilePaths)
            {
                /*Console.WriteLine(Path.Combine(backupPath, filePath));*/
                File.Move(Path.Combine(gamePath, filePath), Path.Combine(backupPath, filePath), overwrite:true);
            }
        }

        /// <summary>
        /// Gets all rules which apply to <paramref name="armor"/>
        /// </summary>
        /// <param name="armor">The Armor record to check</param>
        /// <param name="linkCache">Link cache to retrieve Keywords with</param>
        /// <returns>All rules which apply to <paramref name="armor"/>, ordered in ascending order by <see cref="KeywordRules.Priority"/></returns>
        public static SortedList<int, HHSRules> GetAllRulesForArmor(IArmorGetter armor, ILinkCache linkCache, IEnumerable<HHSRules> allRules)
        {
            var rules = new SortedList<int, HHSRules>();
            foreach (var rule in allRules)
            {
                if (rule.MatchingRules.NifRegex == null)
                {
                    Console.WriteLine("no nifregex");
                } else
                {
                    //Console.WriteLine($"NIF REGEX: {rule.MatchingRules.NifRegex}");
                }
                if (IsArmorMatchedBySetting(armor, rule.MatchingRules, linkCache))
                {
                    rules[rule.Priority] = rule;
                }
            }
            return rules;
        }

        /*public static void ProcessArmor(IArmor armor, ILinkCache linkCache, IEnumerable<HHS>)
        {
            ApplyRulesToArmor(armor, GetAllRulesForArmor(armor, linkCache));
        }*/

        public static void RunPatch(IPatcherState<IFallout4Mod, IFallout4ModGetter> state)
        {
            var shortenedLoadOrder = Settings.ModsToPatch.Any() ? state.LoadOrder.PriorityOrder
                .Where(mod => Settings.ModsToPatch.Contains(mod.ModKey)) : state.LoadOrder.PriorityOrder;

            var linkCache = shortenedLoadOrder.ToImmutableLinkCache();

            /*foreach(var filePath in GetAllValidHHSFiles(state.DataFolderPath.RelativePath).Select(filePath => Path.GetRelativePath(state.DataFolderPath, filePath)))
            {
                Console.WriteLine(filePath);
            }*/


            var f4seFiles = GetAllValidHHSFiles(Path.Join(state.DataFolderPath.RelativePath, "F4SE", "Plugins", "HHS"));
            var meshFiles = GetAllValidHHSFiles(Path.Join(state.DataFolderPath.RelativePath, "Meshes"));
            var allValidFiles = f4seFiles.Concat(meshFiles);
            //var allValidFiles = GetAllValidHHSFiles(state.DataFolderPath.RelativePath).Select(filePath => Path.GetRelativePath(state.DataFolderPath, filePath));
            var allRules = Settings.Rules.Concat(HHSFilesToRules(allValidFiles));
            Console.WriteLine($"We now got {allRules.Count()} rules");

            Console.WriteLine("Files got");

            foreach (var armor in shortenedLoadOrder.WinningOverrides<IArmorGetter>())
            {
                var rules = GetAllRulesForArmor(armor, linkCache, allRules);
                var newArmor = armor.DeepCopy();
                if (ApplyRulesToArmor(newArmor, rules))
                {
                    Console.WriteLine($"Applied rule to {newArmor.Name}");
                    state.PatchMod.Armors.Add(newArmor);
                }
            }

            Console.WriteLine("======Patch Completed-==========");

            MoveFiles(allValidFiles, Path.Combine(state.DataFolderPath, "HeelsBackup"), state.DataFolderPath.RelativePath);
        }
    }
}
